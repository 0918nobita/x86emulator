# x86 エミュレータ

「自作エミュレータで学ぶ x86 アーキテクチャ」を読みながら書いたソースファイル等

## 開発環境

- ThinkPad X230 (Arch linux) 

## やったこと

```bash
$ sudo pacman -Syu
$ sudo pacman -S nasm
$ gcc -Wl,--entry=func,--oformat=binary -nostdlib -fno-asynchronous-unwind-tables -o casm-c-sample.bin casm-c-sample.c
$ ndisasm -b 32 casm-c-sample.bin
$ gcc -c -g -o casm-c-sample.o casm-c-sample.c
$ objdump -d -S -M intel casm-c-sample.o
```

生成されたアセンブリ言語プログラム

```
push ebp
dec eax
mov ebp,esp
mov dword [ebp-0x4],0x0
add dword [ebp-0x4],byte +0x1
nop
pop ebp
ret
```

``オペコード オペランド1, オペランド2``

オペコードとオペランドを合わせたものを**ニーモニック**と呼ぶ

## `mov` 命令

- データの移動
- どこからどこへ移動するのかをオペランドで指定。

```
mov 移動先, 移動元
```

- 一度に移動できるデータは 4 / 2 / 1 バイト
- 移動元には変更を加えないため「コピー」とも言える。
- C言語での「代入文」に相当する

``mov ebp,esp`` は ``esp`` から ``ebp`` への値のコピー

``esp`` や ``ebp`` は **レジスタ** と呼ばれる記憶領域で、CPU に内蔵されている

``esp`` は **スタックポインタ** と呼ばれ、常にスタックの最新の読み書き位置を保持している

スタック … ローカル変数を置くためのデータ領域  
その中の1箇所を指し示すものがスタックポインタ  
``esp`` の値はいろいろなアセンブリ命令の実行により変更されてしまうため、  
その瞬間のスタックポインタを後で使うために ``ebp`` にコピーしている

``mov dword [ebp-0x4],0x0`` はコピー元が ``0x0`` で、コピー先が ``dword [ebp-0x4]`` 

- コピー元に数値を指定すれば、コピーする値を直接指定できる (この値を **即値** や **リテラル** と呼ぶ)
- ``ebp-0x4`` ではコピー先のメモリ番地を計算している
- 単なる数値ではなく、メモリ番地だと意味づけする ``[ ]``
- 領域の大きさを指定する部分 ``dword``

そもそも、「メモリ」はデータを記録できる大きな領域  
そのメモリを細かく区分けして連番を振ったのが「メモリ番地」  
1つ1つの区画には 8 ビット分のデータを記憶できる

今まではデータを記憶するためにレジスタを使ってきたが、メモリもレジスタのようにデータを書き込んだり、読み出したりできる  
そして、アセンブリ言語でメモリを読み書きするには ``[ ]`` でメモリ番地を囲むことになっている

変数 ``val`` は ``ebp`` で示されるスタック上の位置から ``4`` だけ前方にずれたところにあるため、``ebp-4`` が変数 ``val`` の先頭位置となる  
※ 変数 val が ebp から 4 だけずれた場所にあるのは C 言語の規格ではなく、使ったコンパイラが偶然そこを選んだだけ

``esp`` が通常のスタックポインタ  
``ebp`` がベースポインタ  
関数呼び出しごとにベースとなるスタック位置を保存して ``ebp`` の前後で関数引数の変数や、関数内の変数にアクセスする  
``esp`` のスタック操作があっても ``ebp`` は固定で変わらないのでローカル変数に安定してアクセスできる
