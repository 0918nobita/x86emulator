# x86 エミュレータ

「自作エミュレータで学ぶ x86 アーキテクチャ」を読みながら書いたソースファイル等

## サンプルコードについて

| 範囲 | 内容 | ソースコード |
| --- | --- | --- |
| 12 〜 28 | コンパイルと逆アセンブル, オペランド/オペコード/ニーモニック, mov/inc 命令 | `casm-c-sample.c` |
| 39 〜 42 | メモリ, lea 命令, リトル/ビッグエンディアン | `list2-4.c` |

## 環境構築

Arch linux がインストール済みの場合

```bash
$ sudo pacman -Syu
# NASM のインストール
$ sudo pacman -S nasm
```

``オペコード オペランド1, オペランド2``

オペコードとオペランドを合わせたものを**ニーモニック**と呼ぶ

## `mov` 命令

- データの移動
- どこからどこへ移動するのかをオペランドで指定。

```
mov 移動先, 移動元
```

- 一度に移動できるデータは 4 / 2 / 1 バイト
- 移動元には変更を加えないため「コピー」とも言える。
- C言語での「代入文」に相当する

``mov ebp,esp`` は ``esp`` から ``ebp`` への値のコピー

``esp`` や ``ebp`` は **レジスタ** と呼ばれる記憶領域で、CPU に内蔵されている

``esp`` は **スタックポインタ** と呼ばれ、常にスタックの最新の読み書き位置を保持している

スタック … ローカル変数を置くためのデータ領域  
その中の1箇所を指し示すものがスタックポインタ  
``esp`` の値はいろいろなアセンブリ命令の実行により変更されてしまうため、  
その瞬間のスタックポインタを後で使うために ``ebp`` にコピーしている

``mov dword [ebp-0x4],0x0`` はコピー元が ``0x0`` で、コピー先が ``dword [ebp-0x4]`` 

- コピー元に数値を指定すれば、コピーする値を直接指定できる (この値を **即値** や **リテラル** と呼ぶ)
- ``ebp-0x4`` ではコピー先のメモリ番地を計算している
- 単なる数値ではなく、メモリ番地だと意味づけする ``[ ]``
- 領域の大きさを指定する部分 ``dword``

そもそも、「メモリ」はデータを記録できる大きな領域  
そのメモリを細かく区分けして連番を振ったのが「メモリ番地」  
1つ1つの区画には 8 ビット分のデータを記憶できる

今まではデータを記憶するためにレジスタを使ってきたが、メモリもレジスタのようにデータを書き込んだり、読み出したりできる  
そして、アセンブリ言語でメモリを読み書きするには ``[ ]`` でメモリ番地を囲むことになっている

変数 ``val`` は ``ebp`` で示されるスタック上の位置から ``4`` だけ前方にずれたところにあるため、``ebp-4`` が変数 ``val`` の先頭位置となる  
※ 変数 val が ebp から 4 だけずれた場所にあるのは C 言語の規格ではなく、使ったコンパイラが偶然そこを選んだだけ

- ``esp`` : 通常のスタックポインタ
- ``ebp`` : ベースポインタ
- 関数呼び出しごとにベースとなるスタック位置を保存して ``ebp`` の前後で関数引数の変数や、関数内の変数にアクセスする
- ``esp`` のスタック操作があっても ``ebp`` は固定で変わらないのでローカル変数に安定してアクセスできる

- 関数呼び出しのときにスタックに引数を push して、関数の呼び出し後にベースポインタをスタックポインタに更新するので、  
  ベースポインタの手前には関数への引数があったりするので、ebp-0x4 なんて場所に値を書き込んでも問題はないらしい

## `inc` 命令

```
inc インクリメント対象
```

例のプログラムでは ``inc dword [ebp-0x4]``  
``dword [ebp-0x4]`` で変数 ``val`` を指定している

- 2 つの機械語命令が 1 つのアセンブリ言語に対応する例外的な命令
